% [field-mode] is true if we are on a realFieldType,
% otherwise we are on a realDomainType.
pred field-mode.

% [ring->field Ring Field]: [Field] is optionally a [fieldType] instance such
% that [GRing.Field.ringType Field = Ring].
pred ring->field i:term, o:option term.
ring->field R (some F) :-
  field-mode,
  coq.unify-eq {{ GRing.Ring.sort lp:R }} {{ GRing.Field.sort lp:F }} ok, !.
ring->field _ none.

% Type to contain the carrier type and the following structure instances
% attached to it: realFieldType (optional), realDomainType,
% fieldType (optional), unitRingType (optional), ringType, porderType, eqType,
% Type
kind carrier type.
type carrier option term -> term -> option term -> option term -> term ->
             term -> term -> Type -> carrier.

pred type->carrier i:term, o:carrier, o:prop.
type->carrier Ty (carrier (some RF) RD (some F) (some UR) R PO EQ Ty)
              field-mode :-
  std.do! [ coq.unify-eq Ty {{ Num.RealField.sort lp:RF }} ok,
            coq.unify-eq Ty {{ Num.RealDomain.sort lp:RD }} ok,
            coq.unify-eq Ty {{ GRing.Field.sort lp:F }} ok,
            coq.unify-eq Ty {{ GRing.UnitRing.sort lp:UR }} ok,
            coq.unify-eq Ty {{ GRing.Ring.sort lp:R }} ok,
            coq.unify-eq Ty {{ @Order.POrder.sort _ lp:PO }} ok,
            coq.unify-eq Ty {{ Equality.sort lp:EQ }} ok ].
type->carrier Ty (carrier none RD none none R PO EQ Ty) true :-
  std.do! [ coq.unify-eq Ty {{ Num.RealDomain.sort lp:RD }} ok,
            coq.unify-eq Ty {{ GRing.Ring.sort lp:R }} ok,
            coq.unify-eq Ty {{ @Order.POrder.sort _ lp:PO }} ok,
            coq.unify-eq Ty {{ Equality.sort lp:EQ }} ok ].

pred carrier->realField i:carrier, o:term.
carrier->realField (carrier (some RF) _ _ _ _ _ _ _) RF :- !.

pred carrier->realDomain i:carrier, o:term.
carrier->realDomain (carrier _ RD _ _ _ _ _ _) RD :- !.

pred carrier->field i:carrier, o:term.
carrier->field (carrier _ _ (some F) _ _ _ _ _) F :- !.

pred carrier->unitRing i:carrier, o:term.
carrier->unitRing (carrier _ _ _ (some UR) _ _ _ _) UR :- !.

pred carrier->ring i:carrier, o:term.
carrier->ring (carrier _ _ _ _ R _ _ _) R :- !.

pred carrier->porder i:carrier, o:term.
carrier->porder (carrier _ _ _ _ _ PO _ _) PO :- !.

pred carrier->eq i:carrier, o:term.
carrier->eq (carrier _ _ _ _ _ _ EQ _) EQ :- !.

pred carrier->type i:carrier, o:term.
carrier->type (carrier _ _ _ _ _ _ _ Ty) Ty :- !.

pred field->unitRing o:term, o:term.
field->unitRing F R :- !,
  coq.unify-eq {{ GRing_Field__to__GRing_UnitRing lp:F }} R ok.

pred ring->zmod o:term, o:term.
ring->zmod R V :- !, coq.unify-eq {{ GRing_Ring__to__GRing_Zmodule lp:R }} V ok.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parse goal (and hypotheses) to extract a realFieldType or realDomainType
% from (in)equalities it contains

% carrier type from a term of type bool
pred rfstr.bool i:term, o:carrier, o:prop.
rfstr.bool {{ lp:Ty1 ==> lp:Ty2 }} C IsField :- !,
  (rfstr.bool Ty2 C IsField; rfstr.bool Ty1 C IsField).
rfstr.bool {{ ~~ lp:Ty }} C IsField :- !, rfstr.bool Ty C IsField.
rfstr.bool {{ lp:Ty1 && lp:Ty2 }} C IsField :- !,
  (rfstr.bool Ty2 C IsField; rfstr.bool Ty1 C IsField).
rfstr.bool {{ lp:Ty1 || lp:Ty2 }} C IsField :- !,
  (rfstr.bool Ty2 C IsField; rfstr.bool Ty1 C IsField).
rfstr.bool {{ @Order.le _ lp:Ty _ _ }} C IsField :- !,
  type->carrier {{ @Order.POrder.sort _ lp:Ty }} C IsField.
rfstr.bool {{ @Order.lt _ lp:Ty _ _ }} C IsField :- !,
  type->carrier {{ @Order.POrder.sort _ lp:Ty }} C IsField.

% carrier type from a term of type Prop
pred rfstr.prop i:term, o:carrier, o:prop.
rfstr.prop {{ lp:Ty1 -> lp:Ty2 }} C IsField :- !,
  (rfstr.prop Ty2 C IsField; rfstr.prop Ty1 C IsField).
rfstr.prop {{ iff lp:Ty1 lp:Ty2 }} C IsField :- !,
  (rfstr.prop Ty2 C IsField; rfstr.prop Ty1 C IsField).
rfstr.prop {{ ~ lp:Type }} C IsField :- rfstr.prop Type C IsField.
rfstr.prop {{ lp:Ty1 /\ lp:Ty2 }} C IsField :- !,
  (rfstr.prop Ty2 C IsField; rfstr.prop Ty1 C IsField).
rfstr.prop {{ lp:Ty1 \/ lp:Ty2 }} C IsField :- !,
  (rfstr.prop Ty2 C IsField; rfstr.prop Ty1 C IsField).
rfstr.prop {{ is_true lp:Ty }} C IsField :- !, rfstr.bool Ty C IsField.
rfstr.prop {{ @eq lp:Bool lp:Ty1 lp:Ty2 }} C IsField :-
  coq.unify-eq Bool {{ bool }} ok, !,
  (rfstr.bool Ty2 C IsField; rfstr.bool Ty1 C IsField).
rfstr.prop {{ @eq lp:Ty _ _ }} C IsField :- !, type->carrier Ty C IsField.

pred rfstr.hyps i:list prop, o:carrier, o:prop.
rfstr.hyps [decl _ _ H|_] C IsField :- rfstr.prop H C IsField.
rfstr.hyps [_|Ctx] C IsField :- rfstr.hyps Ctx C IsField.

pred rfstr i:list prop, i:term, o:carrier, o:prop.
rfstr _ Type C IsField :- rfstr.prop Type C IsField, !.
rfstr Ctx _ C IsField :- rfstr.hyps {std.rev Ctx} C IsField, !.
rfstr _ _ _ _ :- coq.ltac.fail _ "Cannot find a realDomainType".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Reification procedure

% [coqZ] represents Coq terms of type [Z]. Since we often have to take their
% multiplicative inverse (of type [Q]), we expose the head constructor in the
% Elpi level.
kind coqZ type.
type coqZ0 coqZ.
type coqZpos term -> coqZ.
type coqZneg term -> coqZ.

pred coqZ->N o:coqZ, o:term.
coqZ->N coqZ0 {{ N0 }} :- !.
coqZ->N (coqZpos P) {{ Npos lp:P }} :- !.

pred coqZ->Z o:coqZ, o:term.
coqZ->Z coqZ0 {{ Z0 }} :- !.
coqZ->Z (coqZpos P) {{ Zpos lp:P }} :- !.
coqZ->Z (coqZneg P) {{ Zneg lp:P }} :- !.

pred coqZ->Q i:bool, i:coqZ, o:term.
coqZ->Q _ coqZ0 {{ Qmake 0 1 }} :- !.
coqZ->Q ff (coqZpos P) {{ Qmake (Zpos lp:P) 1 }} :- !.
coqZ->Q ff (coqZneg P) {{ Qmake (Zneg lp:P) 1 }} :- !.
coqZ->Q tt (coqZpos P) {{ Qmake 1 lp:P }} :- !.
coqZ->Q tt (coqZneg P) {{ Qmake (-1) lp:P }} :- !.

% [quote.nat In OutM Out] reifies natural number constant [In] of type [nat] to
% a term [OutM] of type [large_nat] and [Out] of type [coqZ].
pred quote.nat i:term, o:term, o:coqZ.
quote.nat {{ Nat.of_num_uint lp:X }} {{ large_nat_uint lp:X }} Out :-
  ground-uint X, !,
  coq.reduction.cbv.norm {{ N.of_num_uint lp:X }} XN, !,
  coqZ->N Out XN.
quote.nat X {{ large_nat_N lp:XN }} Out :-
  reduction-N {{ N.of_nat lp:X }} XN, !, coqZ->N Out XN.

% [quote.int In OutM Out] reifies integer constant [In] of type [int] to a term
% [OutM] of type [large_int] and [Out] of type [coqZ].
pred quote.int i:term, o:term, o:coqZ.
quote.int {{ Posz (Nat.of_num_uint lp:X) }} {{ large_int_Pos lp:X }} Out :-
  ground-uint X, !,
  coq.reduction.cbv.norm {{ N.of_num_uint lp:X }} XN, !, coqZ->N Out XN.
quote.int {{ Posz lp:N }} {{ large_int_Z lp:NZ }} Out :-
  reduction-Z {{ Z.of_nat lp:N }} NZ, !, coqZ->Z Out NZ.
quote.int {{ Negz (Nat.of_num_uint lp:X) }} {{ large_int_Neg lp:X }}
          (coqZneg P) :-
  ground-uint X, !,
  coq.reduction.cbv.norm {{ N.succ_pos (N.of_num_uint lp:X) }} P.
quote.int {{ Negz lp:N }} {{ large_int_Z (Zneg lp:P) }} (coqZneg P) :-
  reduction-pos {{ N.succ_pos (N.of_nat lp:N) }} P, !.

% [quote.expr Inv R F TR TUR Morph In OutM Out VM] reifies arithmetic
% expressions
% - [Inv] is a Boolean flag indicating that [Out] should represent the
%   multiplicative inverse of [In],
% - [R] is a [ringType] instance,
% - [F] is optionally a [fieldType] instance such that
%   [GRing.Field.ringType F = R],
% - [TR] is a [ringType] instance,
% - [TUR] is optionally an [unitRingType] instance such that
%   [GRing.UnitRing.ringType TUR = TR],
% - [Morph] is a function from [R] to [TR],
% - [In] is a term of type [R],
% - [OutM] is a reified expression of type [RExpr R],
% - [Out] is a reified expression of type [PExpr Q], and
% - [VM] is a variable map, that is a list of terms of type [R].
pred quote.expr i:bool, i:term, i:option term, i:term, i:option term,
    i:(term -> term), i:term, o:term, o:term, o:list term.
% 0%R
quote.expr _ R _ _ _ _ {{ @GRing.zero lp:U }}
           {{ @R0 lp:R }} {{ PEc (Qmake 0 1) }} _ :-
  ring->zmod R U, !.
% -%R
quote.expr Inv R F TR TUR Morph {{ @GRing.opp lp:U lp:In }}
           {{ @ROpp lp:R lp:OutM }} {{ PEopp lp:Out }} VM :-
  ring->zmod R U, !,
  quote.expr Inv R F TR TUR Morph In OutM Out VM.
% +%R
quote.expr ff R F TR TUR Morph {{ @GRing.add lp:U lp:In1 lp:In2 }}
           {{ @RAdd lp:R lp:OutM1 lp:OutM2 }} {{ PEadd lp:Out1 lp:Out2 }} VM :-
  ring->zmod R U, !,
  quote.expr ff R F TR TUR Morph In1 OutM1 Out1 VM, !,
  quote.expr ff R F TR TUR Morph In2 OutM2 Out2 VM.
% (_ *+ _)%R
quote.expr Inv R F TR TUR Morph {{ @GRing.natmul lp:U lp:In1 lp:In2 }}
           {{ @RMuln lp:R lp:OutM1 lp:OutM2 }}
           {{ PEmul lp:Out1 (PEc lp:Out2') }} VM :-
  ring->zmod R U, quote.nat In2 OutM2 Out2, !,
  quote.expr Inv R F TR TUR Morph In1 OutM1 Out1 VM, !,
  coqZ->Q Inv Out2 Out2'.
% (_ *~ _)%R
quote.expr Inv R F TR TUR Morph {{ @intmul lp:U lp:In1 lp:In2 }}
           {{ @RMulz lp:R lp:OutM1 lp:OutM2 }} {{ PEmul lp:Out1 lp:Out2 }} VM :-
  ring->zmod R U, !,
  quote.expr Inv R F TR TUR Morph In1 OutM1 Out1 VM, !,
  quote.expr Inv {{ int_Ring }} none TR TUR
    (n\ {{ @intmul (GRing_Ring__to__GRing_Zmodule lp:TR) (@GRing.one lp:TR) lp:n }})
    In2 OutM2 Out2 VM.
% 1%R
quote.expr _ R _ _ _ _ {{ @GRing.one lp:R' }}
           {{ @R1 lp:R }} {{ PEc (Qmake 1 1) }} _ :-
  coq.unify-eq R R' ok, !.
% *%R
quote.expr Inv R F TR TUR Morph {{ @GRing.mul lp:R' lp:In1 lp:In2 }}
           {{ @RMul lp:R lp:OutM1 lp:OutM2 }} {{ PEmul lp:Out1 lp:Out2 }} VM :-
  coq.unify-eq R R' ok, !,
  quote.expr Inv R F TR TUR Morph In1 OutM1 Out1 VM, !,
  quote.expr Inv R F TR TUR Morph In2 OutM2 Out2 VM.
% (_ ^+ _)%R
quote.expr Inv R F TR TUR Morph {{ @GRing.exp lp:R' lp:In1 lp:In2 }}
           {{ @RExpn lp:R lp:OutM1 lp:OutM2 }}
           {{ PEpow lp:Out1 lp:Out2' }} VM :-
  coq.unify-eq R R' ok, quote.nat In2 OutM2 Out2, !,
  quote.expr Inv R F TR TUR Morph In1 OutM1 Out1 VM, !,
  coqZ->N Out2 Out2'.
% _^-1
quote.expr Inv R (some F) TR TUR Morph {{ @GRing.inv lp:R' lp:In }}
           {{ @RInv lp:F lp:OutM }} Out VM :-
  field-mode,
  field->unitRing F R', !,
  quote.expr { negb Inv } R (some F) TR TUR Morph In OutM Out VM.
% morphisms
quote.expr Inv R _ TR TUR Morph In
           {{ @RMorph lp:R' lp:R lp:NewMorphInst lp:OutM }} Out VM :-
  NewMorph = (x\ {{ @MorphSort.RMorphism lp:R' lp:R lp:NewMorphInst lp:x }}),
  coq.unify-eq In (NewMorph In1) ok, !,
  quote.expr Inv R' { ring->field R' } TR TUR (x\ Morph (NewMorph x)) In1
    OutM Out VM.
% int constants
quote.expr Inv _ _ _ _ _ In {{ RintC lp:OutM }} {{ PEc lp:Out' }} _ :-
  quote.int In OutM Out, !,
  coqZ->Q Inv Out Out'. 
% Z constants
quote.expr _ _ _ _ _ _ {{ Z0 }} {{ RZC Z0 }} {{ PEc (Qmake 0 1) }} _ :- !.
quote.expr Inv _ _ _ _ _ {{ Zpos lp:P }} {{ RZC (Zpos lp:P') }}
           {{ PEc lp:Out }} _ :- !,
  reduction-pos P P', coqZ->Q Inv (coqZpos P') Out.
quote.expr Inv _ _ _ _ _ {{ Zneg lp:P }} {{ RZC (Zneg lp:P') }}
           {{ PEc lp:Out }} _ :- !,
  reduction-pos P P', coqZ->Q Inv (coqZneg P') Out.
% variables
quote.expr ff R _ _ _ Morph In {{ @RX lp:R lp:In }} {{ PEX lp:P }} VM :- !,
  mem VM (Morph In) N, !, positive-constant { calc (N + 1) } P.
quote.expr tt R _ _ (some TUR) Morph In {{ @RX lp:R lp:In }} {{ PEX lp:P }} VM :-
  !,
  mem VM {{ @GRing.inv lp:TUR lp:{{ Morph In }} }} N, !,
  positive-constant { calc (N + 1) } P.
quote.expr _ _ _ _ _ _ In _ _ _ :- coq.error "Unknown" {coq.term->string In}.

% [quote.exprw C In OutM Out VM] reifies arithmetic expressions
% - [C] is the carrier type and structure instances,
% - [In] is a term of type [C],
% - [OutM] is a reified expression of type [RExpr C],
% - [Out] is a reified expression of type [PExpr Q], and
pred quote.exprw i:carrier, i:term, o:term, o:term, o:list term.
quote.exprw (carrier _ _ F TR R _ _ _) In OutM Out VM :-
  quote.expr ff R F R TR (x\ x) In OutM Out VM.

% [quote.bop2 C In OutM Out VM] reifies boolean (in)equalities
% - [C] is the carrier type and structure instances,
% - [In] is a term of type [bool],
% - [OutM] is a reified expression of type [RFormula C],
% - [Out] is a reified expression of type [Formula Q], and
% - [VM] is a variable map, that is a list of terms of type [C].
pred quote.bop2 i:carrier, i:term, o:term, o:term, o:list term.
quote.bop2 C {{ @Order.le _ lp:O lp:X lp:Y }}
           {{ Build_RFormula lp:XM' OpLe lp:YM' }}
           {{ Build_Formula lp:X' OpLe lp:Y' }} VM :-
  coq.unify-eq { carrier->porder C } O ok, !,
  quote.exprw C X XM' X' VM, !, quote.exprw C Y YM' Y' VM.
quote.bop2 C {{ @Order.lt _ lp:O lp:X lp:Y }}
           {{ Build_RFormula lp:XM' OpLt lp:YM' }}
           {{ Build_Formula lp:X' OpLt lp:Y' }} VM :-
  coq.unify-eq { carrier->porder C } O ok, !,
  quote.exprw C X XM' X' VM, !, quote.exprw C Y YM' Y' VM.
quote.bop2 C {{ @eq_op lp:T lp:X lp:Y }}
           {{ Build_RFormula lp:XM' OpEq lp:YM' }}
           {{ Build_Formula lp:X' OpEq lp:Y' }} VM :-
  coq.unify-eq { carrier->eq C } T ok, !,
  quote.exprw C X XM' X' VM, !, quote.exprw C Y YM' Y' VM.

% [quote.pop2 C In OutM Out VM] reifies (in)equalities of type Prop
% - [C] is the carrier type and structure instances,
% - [In] is a term of type [Prop],
% - [OutM] is a reified expression of type [RFormula C],
% - [Out] is a reified expression of type [Formula Q], and
% - [VM] is a variable map, that is a list of terms of type [C].
pred quote.pop2 i:carrier, i:term, o:term, o:term, o:list term.
quote.pop2 C {{ is_true lp:E }} OutM Out VM :- quote.bop2 C E OutM Out VM.
quote.pop2 C {{ @eq lp:T lp:X lp:Y }}
           {{ Build_RFormula lp:XM' OpEq lp:YM' }}
           {{ Build_Formula lp:X' OpEq lp:Y' }} VM :-
  coq.unify-eq {carrier->type C} T ok, !,
  quote.exprw C X XM' X' VM, !, quote.exprw C Y YM' Y' VM.

% GFormula constructors
pred build.implb i:term, i:term, o:term.
build.implb {{ X _ lp:In1 }} {{ X _ lp:In2 }}
            {{ X isBool (lp:In1 ==> lp:In2) }} :- !.
build.implb In1 In2 {{ IMPL lp:In1 None lp:In2 }} :- !.

pred build.andb i:term, i:term, o:term.
build.andb {{ X _ lp:In1 }} {{ X _ lp:In2 }}
           {{ X isBool (lp:In1 && lp:In2) }} :- !.
build.andb In1 In2 {{ AND lp:In1 lp:In2 }} :- !.

pred build.orb i:term, i:term, o:term.
build.orb {{ X _ lp:In1 }} {{ X _ lp:In2 }}
          {{ X isBool (lp:In1 || lp:In2) }} :- !.
build.orb In1 In2 {{ OR lp:In1 lp:In2 }} :- !.

pred build.negb i:term, o:term.
build.negb {{ X _ lp:In1 }} {{ X isBool (~~ lp:In1) }} :- !.
build.negb In {{ NOT lp:In }} :- !.

pred build.implp i:term, i:term, o:term.
build.implp {{ X _ lp:In1 }} {{ X _ lp:In2 }}
            {{ X isProp (lp:In1 -> lp:In2) }} :- !.
build.implp In1 In2 {{ IMPL lp:In1 None lp:In2 }} :- !.

pred build.iffp i:term, i:term, o:term.
build.iffp {{ X _ lp:In1 }} {{ X _ lp:In2 }}
            {{ X isProp (iff lp:In1 lp:In2) }} :- !.
build.iffp In1 In2 {{ IFF lp:In1 lp:In2 }} :- !.

pred build.andp i:term, i:term, o:term.
build.andp {{ X _ lp:In1 }} {{ X _ lp:In2 }}
           {{ X isProp (lp:In1 /\ lp:In2) }} :- !.
build.andp In1 In2 {{ AND lp:In1 lp:In2 }} :- !.

pred build.orp i:term, i:term, o:term.
build.orp {{ X _ lp:In1 }} {{ X _ lp:In2 }}
          {{ X isProp (lp:In1 \/ lp:In2) }} :- !.
build.orp In1 In2 {{ OR lp:In1 lp:In2 }} :- !.

pred build.negp i:term, o:term.
build.negp {{ X _ lp:In1 }} {{ X isProp (~ lp:In1) }} :- !.
build.negp In {{ NOT lp:In }} :- !.

% [quote.bool C In OutM Out VM] reifies boolean formulas
% - [C] is the carrier type and structure instances,
% - [In] is a term of type [bool],
% - [OutM] is a reified formula of type [BFormula (RFormula C) isBool],
% - [Out] is a reified formula of type [BFormula (Formula Q) isBool], and
% - [VM] is a variable map, that is a list of terms of type [C].
pred quote.bool i:carrier, i:term, o:term, o:term, o:list term.
quote.bool C {{ lp:In1 ==> lp:In2 }} OutM Out VM :- !, std.do!
  [quote.bool C In1 OutM1 Out1 VM, quote.bool C In2 OutM2 Out2 VM,
   build.implb OutM1 OutM2 OutM, build.implb Out1 Out2 Out].
quote.bool C {{ lp:In1 && lp:In2 }} OutM Out VM :- !, std.do!
  [quote.bool C In1 OutM1 Out1 VM, quote.bool C In2 OutM2 Out2 VM,
   build.andb OutM1 OutM2 OutM, build.andb Out1 Out2 Out].
quote.bool C {{ lp:In1 || lp:In2 }} OutM Out VM :- !, std.do!
  [quote.bool C In1 OutM1 Out1 VM, quote.bool C In2 OutM2 Out2 VM,
   build.orb OutM1 OutM2 OutM, build.orb Out1 Out2 Out].
quote.bool C {{ ~~ lp:In1 }} OutM Out VM :- !, std.do!
  [quote.bool C In1 OutM1 Out1 VM, build.negb OutM1 OutM, build.negb Out1 Out].
quote.bool _ {{ true }} {{ TT isBool }} {{ TT isBool }} _ :- !.
quote.bool _ {{ false }} {{ FF isBool }} {{ FF isBool }} _ :- !.
quote.bool C In {{ A isBool lp:OutM tt }} {{ A isBool lp:Out tt }} VM :-
  quote.bop2 C In OutM Out VM.
quote.bool _ In {{ X isBool lp:In }} {{ X isBool lp:In }} _ :- !.

% [quote.prop C In OutM Out VM] reifies formulas of type Prop
% - [C] is the carrier type and structure instances,
% - [In] is a term of type [Prop],
% - [OutM] is a reified formula of type [BFormula (RFormula C) isProp],
% - [Out] is a reified formula of type [BFormula (Formula Q) isProp], and
% - [VM] is a variable map, that is a list of terms of type [C].
pred quote.prop i:carrier, i:term, o:term, o:term, o:list term.
quote.prop C {{ lp:In1 -> lp:In2 }} OutM Out VM :- !, std.do!
  [quote.prop C In1 OutM1 Out1 VM, quote.prop C In2 OutM2 Out2 VM,
   build.implp OutM1 OutM2 OutM, build.implp Out1 Out2 Out].
quote.prop C {{ iff lp:In1 lp:In2 }} OutM Out VM :- !, std.do!
  [quote.prop C In1 OutM1 Out1 VM, quote.prop C In2 OutM2 Out2 VM,
   build.iffp OutM1 OutM2 OutM, build.iffp Out1 Out2 Out].
quote.prop C {{ lp:In1 /\ lp:In2 }} OutM Out VM :- !, std.do!
  [quote.prop C In1 OutM1 Out1 VM, quote.prop C In2 OutM2 Out2 VM,
   build.andp OutM1 OutM2 OutM, build.andp Out1 Out2 Out].
quote.prop C {{ lp:In1 \/ lp:In2 }} OutM Out VM :- !, std.do!
  [quote.prop C In1 OutM1 Out1 VM, quote.prop C In2 OutM2 Out2 VM,
   build.orb OutM1 OutM2 OutM, build.orb Out1 Out2 Out].
quote.prop C {{ ~ lp:In1 }} OutM Out VM :- !, std.do!
  [quote.prop C In1 OutM1 Out1 VM, build.negp OutM1 OutM, build.negp Out1 Out].
quote.prop _ {{ True }} {{ TT isProp }} {{ TT isProp }} _ :- !.
quote.prop _ {{ False }} {{ FF isProp }} {{ FF isProp }} _ :- !.
quote.prop C {{ is_true lp:In1 }}
           {{ EQ lp:OutM1 (TT isBool) }} {{ EQ lp:Out1 (TT isBool) }} VM :- !,
  quote.bool C In1 OutM1 Out1 VM, !.
quote.prop C {{ @eq lp:Bool lp:In1 lp:In2 }} OutM Out VM :-
  coq.unify-eq Bool {{ bool }} ok, !,
  quote.bool C In1 OutM1 Out1 VM, !, quote.bool C In2 OutM2 Out2 VM, !,
  OutM = {{ EQ lp:OutM1 lp:OutM2 }}, !, Out = {{ EQ lp:Out1 lp:Out2 }}.
quote.prop C In {{ A isProp lp:OutM tt }} {{ A isProp lp:Out tt }} VM :-
  quote.pop2 C In OutM Out VM.
quote.prop _ In {{ X isProp lp:In }} {{ X isProp lp:In }} _ :- !.

% [quote.goal C Ctx Goal Goal' NS OutM Out VM] reifies the goal [Goal],
% including the arithmetic hypotheses in the context [Ctx], in the form of
% implication chain
% - [C] is the carrier type and structure instances,
% - [Ctx] is the context (hypotheses),
% - [Goal] is the goal, of type [Prop],
% - [Goal'] is a chain of implications including [Goal] and hypotheses in [Hyps]
%   that have some arithmetic contents,
% - [NS] are the names of arithmetic hypotheses in [Ctx] added to [Goal'],
% - [OutM] is the reified term of type [BFormula (RFormula C) isProp],
% - [ReifiedOut] is the reified term of type [BFormula (Formula Q) isProp], and
% - [VM] is a variable map, that is a list of terms of type [C].
pred quote.goal i:carrier, i:list prop, i:term,
    o:term, o:list term, o:term, o:term, o:list term.
quote.goal C [decl N _ In1|Ctx] Type {{ lp:In1 -> lp:Type' }} [N|NS]
           {{ IMPL lp:OutM1 None lp:OutM2 }}
           {{ IMPL lp:Out1 None lp:Out2 }} VM :-
  quote.prop C In1 OutM1 Out1 VM, not (Out1 = {{ X _ _ }}), !,
  quote.goal C Ctx Type Type' NS OutM2 Out2 VM.
quote.goal C [_|Ctx] Type Type' NS OutM Out VM :- !,
  quote.goal C Ctx Type Type' NS OutM Out VM.
quote.goal C [] Type Type [] OutM Out VM :- !, quote.prop C Type OutM Out VM.

% [exfalso_if_not_prop In Out Bool] changes [In] to [False]
% when [In] is not a [Prop] (and then set [Bool] to [tt])
pred exfalso_if_not_prop i:term, o:term, o:bool.
exfalso_if_not_prop Type Type ff :- coq.typecheck Type {{ Prop }} ok.
exfalso_if_not_prop _ {{ False }} tt.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Main tactic

pred gen-witness i:string, i:argument, i:term, i:goal, o:sealed-goal.
gen-witness TacW N Out G G' :- coq.ltac.call TacW [N, trm Out] G [G'].
gen-witness _ _ _ _ _ :- coq.ltac.fail 0 "Cannot find witness".

pred lra-reflection i:string, i:term, i:term, i:term, i:term, i:term,
                    i:goal, i:sealed-goal, o:list sealed-goal.
lra-reflection Tac C Hyps OutM Out VM G G' GS :-
  coq.ltac.set-goal-arguments
    [trm C, trm Hyps, trm OutM, trm Out, trm VM] G G' G'',
  coq.ltac.open (g\ gs\ sigma Wit Args Args'\
    % NB: the following line is very specific to the current implementation of
    % the witness generators. We assume that the witness appears as the first
    % item of the context.
    g = goal [def Wit _ _ _|_] _ _ _ Args,
    std.append Args [trm Wit] Args',
    coq.ltac.call Tac Args' g gs) G'' GS.
lra-reflection _ _ _ _ _ _ _ _ _ :-
  coq.ltac.fail 0 "Reflection failed, this is a bug".

% The tactic takes four arguments:
% - [TacW] is the name of the Ltac1 tactic that generates the witness,
% - [TacF] and [TacR] are the names of the Ltac1 tactics to call respectively
%   in the [realFieldType] and [realDomainType] cases, and
% - [N] is passed as is as the first argument of [TacW].
% The [TacW] tactic will receive [N] and the reified term [Out], explained
% below, and the [TacF] or [TacR] tactic will receive six arguments:
% - [N] above,
% - [Hyps] a function of type
%   [(H1 -> ... -> Hn -> G) -> G] (if [G] is a [Prop]) or
%   [(H1 -> ... -> Hn -> False) -> G] (if [G] is not a [Prop])
%   that explicitly passes hypotheses of types [H1], ..., [Hn] taken from the
%   context to the reflexive proof,
% - [OutM] the reified goal as a [BFormula RFormula isProp],
% - [Out] the reified goal as a [BFormula (Formula Q) isProp], and
% - [VM'] a variable map, giving the interpretation to variables in [Out]
%   it is of type [VarMap.t C] where [C] is the carrier for the detected
%   [realFieldType] or [realDomainType].
solve (goal Ctx _ Type _ [str TacW, str TacF, str TacR, N] as G) GS :- std.do! [
  exfalso_if_not_prop Type Type' Efalso,
  rfstr Ctx Type' C IsField,
  (IsField => quote.goal C Ctx Type' Type'' NS OutM Out VM),
  carrier->ring C R,
  std.assert-ok!
    (coq.typecheck OutM {{ BFormula (@RFormula lp:R) isProp }})
    "The reification produced an ill-typed result, this is a bug",
  std.assert-ok!
    (coq.typecheck Out {{ BFormula (Formula Q) isProp }})
    "The reification produced an ill-typed result, this is a bug",
  gen-witness TacW N Out G G',
  list-constant { carrier->type C } VM VM',
  if (Efalso = tt)
     (Hyps = fun _ Type'' (x \ app [{{ False_rect }}, Type, app [x|NS]]))
     (Hyps = fun _ Type'' (x \ app [x|NS])),
  ((carrier->realField C C', Tac = TacF);
   (carrier->realDomain C C', Tac = TacR)),
  lra-reflection Tac C' Hyps OutM Out VM' G G' GS ].
